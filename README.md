# Jets Project

# Description

Third project with Skill Distillery! The Jets Project auto sorts a list of different jets (different types of aircraft, really. Not only jets) from a given .txt document, then presents the user with a menu of options on how they wish to manipulate the aircraft, or get information on the current aircraft in the list. The starting five jets are sorted into three categories based on their description. They are sorted into one of the helicopter, cargo plane, or fighter jet subclasses (of the parent class Jets).

Upon starting up the program, the user is shown a menu from which they may choose to see the current jets in the fleet, fly all jets, view the fastest jet, view the jet with the longest range, load all cargo type jets, dogfight with the fighter jets, add a jet to the fleet, remove a jet from the fleet, or quit the program. 

The first four options display the jets in different ways. The first, list current fleet, simply calls a method in the AirField class to have a printout of every jet, which lists all stored data about the jets in an organized fashion. The second calls another method in the AirField class, with nested loops and conditionals to have every jet display a message about flying, display the type of jet they are (helicopter, cargo plane, or fighter jet), and calculate how long they can stay flying based off of their top speed and range. The third and fourth options are quite similar to each other, displaying the fastest jet and the jet with the farthest range, respectively. They both sort through each jet within the fleet, starting with the first in the list and comparing it to the second. The jet with the higher statistic (speed or range) remains to be compared to the next jet on the list, with the final winner being displayed. 

The next two options, five and six, are to load all cargo jets or have a dogfight with the fighter jets. Both options work in a similar fashion when it came to coding them. Depending on which option is chosen, the corresponding subclass calls upon interfaces specific to them. These interfaces display each jet in their subclass, and add some flavor text into the program. 

The seventh and eighth options are where most of the heavy lifting is done. The user is able to add or remove a jet from the fleet! If they choose to remove a jet, they are presented with a list of all the names of all current jets, asked which one they would like to remove, and then are asked whether they would like to remove another jet. The add jet option gets some basic info from the user, including which type of jet they would like to add, the jet's speed, range, name, and cost. After the jet has been added, they are again prompted to either add another or stop adding new jets. Once these jets have been added or removed, the previous displays are adjusted accordingly. Removed jets no longer show up when the fleet is displayed, but added jets do. They are also appropriately compared when figuring out the fastest or farthest flying jet!


# What I learned

I feel like I grew leaps and bounds with this project, and it feels wonderful. Before I typed my first line of code, I felt completely overwhelmed by the scope. So many different classes, subclasses, and interfaces! And possibly millions of methods, maybe more. I was still very shaky on interfaces, and nested loops and conditionals were confusing and intimidating. I started with a very, very, *very* bare bones UML, which helped focus my thoughts. I began breaking down the task one step at a time, and this was crucial. By simply having the jets sorted into a list from the start, I had several starting classes to work with. An abstract parent class, three subclasses, and application class, and an AirField class into which went an ArrayList (my new best friend) of the jet objects. Great starting point! Going through the menu options one by one, and breaking down the information in the text document into strings gave me a lot of focused, task based coding to sink my teeth into. At one point, I had to get assistance from a TA who helped me resolve downcasting issues that I was having, in order to distinguish the correct subclass I wanted (syntax save lives, folks. That lesson I learned the hard way. No matter how many times I tried to put brackets where I needed parenthesis, or periods where I needed, well, nothing at all, caused me about 10 points of cringe damage).  

Once I had all of the general ideas down, I had a really good time. I significantly strengthened my ability to follow logic in the java language. It's really wild for me to look at the nested loops and logic that I was able to write, completely by myself, with no assistance at all. Just a few days ago I remember looking at a for loop within a for loop, and struggling to track what was happening. I now feel so much more comfortable with more convoluted logic paths. I learned so much about the use and value of interfaces, abstract classes, and up and downcasting. I continue to have luck searching up any errors I encounter, and am responsible for a measurable percentage of Stack Overflow's traffic over the weekend. In terms of personal coding growth, the number of errors I encounter throughout the creation of the program has significantly dropped. Each time I encounter one, I have had a pretty good idea as to what happened and why. I am proud to say that I don't think I had a single instance of "let's hit play, see what the heck happens, try to figure out why it happened, and adjust the code from there!" Each time I ran the program, I knew exactly what I expected to happen. And sometimes, I was even right! 


# Technologies Used

Git, Eclipse, Java. Can I count Stack Overflow, here? I'm counting Stack Overflow.